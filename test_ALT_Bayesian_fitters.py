"""
Bayesian Accelerated Life Testing (ALT) Fitters — Validation Suite
===================================================================

This module provides a test suite to validate the Bayesian ALT fitters
implemented in `reliability.ALT_Bayesian_fitters`.

Purpose
-------
These tests ensure that all Bayesian life–stress model wrappers:
    • Execute end-to-end on synthetic data without numerical errors.
    • Expose complete and finite posterior summaries.
    • Produce physically consistent use-level life predictions.
    • Preserve monotonic stress–life relationships.
    • Integrate cleanly with ArviZ for posterior visualization.

Scope
-----
The suite covers single- and dual-stress Bayesian ALT models:
    - Fit_Exponential_Power_Bayesian
    - Fit_Exponential_Exponential_Bayesian
    - Fit_Normal_Exponential_Bayesian
    - Fit_Exponential_Dual_Power_Bayesian
    - Fit_Lognormal_Power_Exponential_Bayesian

Each test uses synthetic ALT datasets generated by `make_ALT_data()` and
checks for consistency of posterior structure, sign conventions, and qualitative behavior.

These are *consistency and sanity tests*, not convergence or precision benchmarks.
"""

import importlib.util
import numpy as np
import pytest
from reliability.Other_functions import make_ALT_data
from reliability.ALT_Bayesian_fitters import (
    Fit_Exponential_Power_Bayesian,
    Fit_Exponential_Exponential_Bayesian,
    Fit_Normal_Exponential_Bayesian,
    Fit_Exponential_Dual_Power_Bayesian,
    Fit_Lognormal_Power_Exponential_Bayesian,
)

# ---------------------------------------------------------------------------
# Global Bayesian Sampler Settings (kept light for CI / regression testing)
# ---------------------------------------------------------------------------
KW = dict(
    n_walkers=48,
    n_steps=800,
    burn=400,
    thin=2,
    progress=False,
    random_seed=123,
)


# ---------------------------------------------------------------------------
# Helper Functions
# ---------------------------------------------------------------------------

def _has_posterior_table(m):
    """
    Verify that the model exposes valid posterior summary attributes.
    Checks existence and finiteness of mean, std, median, and credible interval bounds.
    """
    def _finite(x):
        return np.isfinite(np.asarray(x)).all()

    ok = True
    # Check core posterior attributes (means, stds, medians)
    for name in dir(m):
        if name.endswith(("_post_mean", "_post_std", "_post_median")):
            ok &= _finite(getattr(m, name))

    # Check credible interval ordering (lo < hi)
    for prefix in ("a", "b", "c", "m", "n", "sigma", "beta"):
        lo, hi = f"{prefix}_post_lo", f"{prefix}_post_hi"
        if hasattr(m, lo) and hasattr(m, hi):
            lo_v, hi_v = getattr(m, lo), getattr(m, hi)
            if np.isfinite(lo_v).all() and np.isfinite(hi_v).all():
                assert np.all(np.asarray(lo_v) < np.asarray(hi_v))
    return ok


def _posterior_use_life(m):
    """
    Evaluate the model’s posterior mean life at the use-level stress(es).
    Ensures the computed life is finite and positive.
    """
    S = m.use_level_stress
    y = m.USE_LIFE_FUNC_POST(m, S)
    y = float(np.asarray(y).squeeze())
    assert y > 0.0
    return y


def _monotonicity_check_single_power_like(m, s_hi=500, s_lo=300):
    """
    For models L(S) = a * S^n with n < 0,
    lower stress should yield longer life.
    """
    L_hi = float(m.USE_LIFE_FUNC_POST(m, s_hi))
    L_lo = float(m.USE_LIFE_FUNC_POST(m, s_lo))
    assert L_lo > L_hi


def _monotonicity_check_single_exponential_like(m, s_hi=500, s_lo=300):
    """
    For models L(S) = b * exp(a / S) with a > 0,
    decreasing stress should increase life.
    """
    L_hi = float(m.USE_LIFE_FUNC_POST(m, s_hi))
    L_lo = float(m.USE_LIFE_FUNC_POST(m, s_lo))
    assert L_lo > L_hi


def _monotonicity_check_dual_power(m, s1_hi=500, s1_lo=200, s2_hi=10, s2_lo=5):
    """
    For dual-stress models L(S1, S2) = c * S1^m * S2^n with m, n < 0,
    lowering either stress should increase life.
    """
    L_hi_hi = float(m.USE_LIFE_FUNC_POST(m, [s1_hi, s2_hi]))
    L_lo_hi = float(m.USE_LIFE_FUNC_POST(m, [s1_lo, s2_hi]))
    L_hi_lo = float(m.USE_LIFE_FUNC_POST(m, [s1_hi, s2_lo]))
    assert L_lo_hi > L_hi_hi  # Lowering S1 increases life
    assert L_hi_lo > L_hi_hi  # Lowering S2 increases life


def _monotonicity_check_power_exponential(m, s1_hi=500, s1_lo=200, s2_hi=10, s2_lo=5):
    """
    For mixed models L(S1, S2) = a * S1^n * exp(c / S2) with n < 0, c > 0,
    lowering either stress increases life.
    """
    L_hi_hi = float(m.USE_LIFE_FUNC_POST(m, [s1_hi, s2_hi]))
    L_lo_hi = float(m.USE_LIFE_FUNC_POST(m, [s1_lo, s2_hi]))
    L_hi_lo = float(m.USE_LIFE_FUNC_POST(m, [s1_hi, s2_lo]))
    assert L_lo_hi > L_hi_hi
    assert L_hi_lo > L_hi_hi


# ---------------------------------------------------------------------------
# Single-Stress Model Tests
# ---------------------------------------------------------------------------

def test_Exponential_Power_Bayesian_single_stress():
    """Validate Bayesian Exponential–Power model behavior."""
    data = make_ALT_data(
        distribution="Exponential",
        life_stress_model="Power",
        a=5e15, n=-4,
        stress_1=[500, 400, 350],
        number_of_samples=120,
        fraction_censored=0.2,
        seed=1,
    )
    m = Fit_Exponential_Power_Bayesian(
        failures=data.failures,
        failure_stress=data.failure_stresses,
        right_censored=data.right_censored,
        right_censored_stress=data.right_censored_stresses,
        use_level_stress=300,
        **KW
    )
    assert _has_posterior_table(m)
    _monotonicity_check_single_power_like(m)
    if hasattr(m, "n_post_mean"):
        assert float(m.n_post_mean) < 0.0
    assert _posterior_use_life(m) > 0.0


def test_Exponential_Exponential_Bayesian_single_stress():
    """Validate Bayesian Exponential–Exponential model behavior."""
    data = make_ALT_data(
        distribution="Exponential",
        life_stress_model="Exponential",
        a=2000, b=10,
        stress_1=[500, 400, 350],
        number_of_samples=100,
        fraction_censored=0.2,
        seed=2,
    )
    m = Fit_Exponential_Exponential_Bayesian(
        failures=data.failures,
        failure_stress=data.failure_stresses,
        right_censored=data.right_censored,
        right_censored_stress=data.right_censored_stresses,
        use_level_stress=300,
        **KW
    )
    assert _has_posterior_table(m)
    _monotonicity_check_single_exponential_like(m)
    if hasattr(m, "a_post_mean"):
        assert np.isfinite(float(m.a_post_mean))
    if hasattr(m, "b_post_mean"):
        assert float(m.b_post_mean) > 0.0
    assert _posterior_use_life(m) > 0.0


def test_Normal_Exponential_Bayesian_single_stress():
    """Validate Bayesian Normal–Exponential model behavior."""
    data = make_ALT_data(
        distribution="Normal",
        life_stress_model="Exponential",
        a=500, b=1000, sigma=500,
        stress_1=[500, 400, 350],
        number_of_samples=100,
        fraction_censored=0.2,
        seed=4,
    )
    m = Fit_Normal_Exponential_Bayesian(
        failures=data.failures,
        failure_stress=data.failure_stresses,
        right_censored=data.right_censored,
        right_censored_stress=data.right_censored_stresses,
        use_level_stress=300,
        **KW
    )
    assert _has_posterior_table(m)
    assert float(m.sigma_post_mean) > 0.0
    _monotonicity_check_single_exponential_like(m)
    assert _posterior_use_life(m) > 0.0


# ---------------------------------------------------------------------------
# Dual-Stress Model Tests
# ---------------------------------------------------------------------------

def test_Exponential_Dual_Power_Bayesian_dual_stress():
    """Validate Bayesian Exponential Dual–Power model behavior."""
    data = make_ALT_data(
        distribution="Exponential",
        life_stress_model="Dual_Power",
        c=1e15, m=-4, n=-2,
        stress_1=[500, 400, 350, 420, 245],
        stress_2=[12, 8, 6, 9, 10],
        number_of_samples=100,
        fraction_censored=0.2,
        seed=5,
    )
    m = Fit_Exponential_Dual_Power_Bayesian(
        failures=data.failures,
        failure_stress_1=data.failure_stresses_1,
        failure_stress_2=data.failure_stresses_2,
        right_censored=data.right_censored,
        right_censored_stress_1=data.right_censored_stresses_1,
        right_censored_stress_2=data.right_censored_stresses_2,
        use_level_stress=[200, 5],
        **KW
    )
    assert _has_posterior_table(m)
    _monotonicity_check_dual_power(m)
    if hasattr(m, "m_post_mean"):
        assert float(m.m_post_mean) < 0.0
    if hasattr(m, "n_post_mean"):
        assert float(m.n_post_mean) < 0.0
    assert _posterior_use_life(m) > 0.0


def test_Lognormal_Power_Exponential_Bayesian_dual_stress():
    """Validate Bayesian Lognormal Power–Exponential model behavior."""
    data = make_ALT_data(
        distribution="Lognormal",
        life_stress_model="Power_Exponential",
        a=200, c=400, n=-0.5, sigma=0.5,
        stress_1=[500, 400, 350, 420, 245],
        stress_2=[12, 8, 6, 9, 10],
        number_of_samples=100,
        fraction_censored=0.5,
        seed=6,
    )
    m = Fit_Lognormal_Power_Exponential_Bayesian(
        failures=data.failures,
        failure_stress_1=data.failure_stresses_1,
        failure_stress_2=data.failure_stresses_2,
        right_censored=data.right_censored,
        right_censored_stress_1=data.right_censored_stresses_1,
        right_censored_stress_2=data.right_censored_stresses_2,
        use_level_stress=[200, 5],
        **KW
    )
    assert _has_posterior_table(m)
    assert float(m.sigma_post_mean) > 0.0
    _monotonicity_check_power_exponential(m)
    if hasattr(m, "n_post_mean"):
        assert float(m.n_post_mean) < 0.0
    if hasattr(m, "c_post_mean"):
        assert float(m.c_post_mean) > 0.0
    assert _posterior_use_life(m) > 0.0


# ---------------------------------------------------------------------------
# ArviZ Integration Test
# ---------------------------------------------------------------------------

@pytest.mark.skipif(importlib.util.find_spec("arviz") is None, reason="ArviZ not installed")
def test_arviz_idata_created_when_show_plots_true():
    """
    Confirm that ArviZ InferenceData is attached when `show_bayes_plots=True`.
    """
    data = make_ALT_data(
        distribution="Exponential",
        life_stress_model="Power",
        a=5e15, n=-4,
        stress_1=[500, 400, 350],
        number_of_samples=60,
        fraction_censored=0.2,
        seed=8,
    )
    m = Fit_Exponential_Power_Bayesian(
        failures=data.failures,
        failure_stress=data.failure_stresses,
        right_censored=data.right_censored,
        right_censored_stress=data.right_censored_stresses,
        use_level_stress=300,
        show_bayes_plots=True,
        **{**KW, "n_steps": 600, "burn": 200}
    )
    assert hasattr(m, "az_idata")
    assert m.az_idata is not None
